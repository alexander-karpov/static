<html>

<body>
    <style>
        #outgoing {
            width: 600px;
            word-wrap: break-word;
            white-space: normal;
        }
    </style>
    <form>
        <textarea id="incoming"></textarea>
    </form>
    <pre id="outgoing"></pre>
    <script src="simplepeer.min.js"></script>
    <script>
        const config = {
            channelConfig: { ordered: false },
            config: {
                iceServers: [
                    {
                        urls: "stun:openrelay.metered.ca:80",
                    },
                    {
                        urls: "turn:openrelay.metered.ca:80",
                        username: "openrelayproject",
                        credential: "openrelayproject",
                    },
                    {
                        urls: "turn:openrelay.metered.ca:443",
                        username: "openrelayproject",
                        credential: "openrelayproject",
                    },
                    {
                        urls: "turn:openrelay.metered.ca:443?transport=tcp",
                        username: "openrelayproject",
                        credential: "openrelayproject",
                    },
                ]
            },
            trickle: false
        };


        class RealtimeX {
            constructor() {
                this.peer = null;
                this.ws = null;
                this.connectResolve = null;
                this.connectReject = null;
                this.receiveHandler = null;
            }

            connect() {
                this.ws = new WebSocket('wss://yoide.su:3001');

                this.ws.onmessage = (event) => {
                    const action = JSON.parse(event.data.toString('utf8'));

                    console.log('ws.onmessage:', action)

                    switch (action.type) {
                        case 'start':
                            this.createPeer(true);
                            break;
                        case 'signal':
                            if (!this.peer) {
                                this.createPeer(false);
                            }

                            this.peer.signal(action.signal);
                            break;
                        default:
                            this.connectReject(new Error(`Enexpected action type ${action.type}`));

                    }
                };

                return new Promise((resolve, reject) => {
                    this.connectResolve = resolve;
                    this.connectReject = reject;
                });
            }


            createPeer(initiator) {
                this.peer = new SimplePeer({
                    initiator,
                    ...config
                });

                this.peer.on('signal', signal => {
                    console.log('peer onsignal')
                    this.ws.send(JSON.stringify({ type: 'signal', signal }))
                })

                this.peer.on('connect', () => {
                    // wait for 'connect' event before using the data channel
                    alert('connected');
                    this.connectResolve();
                })

                this.peer.on('error', err => {
                    console.log('peer onerror')
                    this.connectReject(err);
                });

                this.peer.on('data', data => {
                    if (this.receiveHandler) {
                        this.receiveHandler(data);
                    }
                });
            }

            send(data) {
                this.peer.send(data);
            }

            receive(handler) {
                this.receiveHandler = handler;
            }
        }

        const realtime = new RealtimeX();


        realtime.connect();



        const ta = document.getElementById('incoming');

        realtime.receive(data => ta.value = data.toString('utf8'));

        ta.addEventListener('input', function (e) {
            realtime.send(e.target.value);
        });
    </script>
</body>

</html>
